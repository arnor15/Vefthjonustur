// rendered on server
public ActionResult bla() {
    return View(new ViewModel());
}

// rendered on client
public ActionResult bla() {
    return Json(new ViewModel(), JsonBehavior.AllowGet);
}


/*
 * rest service
*/

/records
/records/75
/records/75/songs/842/lyrics

/records
/songs
/performers

(ekki bua til api sem er svona: /getrecords)
HTTP Verbs bydur upp a GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD, ...
hafa frekar resource-id /records

        /records                /records/75
GET     skilar lista            skilar staki
POST    byr til nyja plotu      X
PUT     X                       
DELETE  eydir lista             eydir staki
PATCH   X                       breytir staki (ad hluta)


Ef GET a 75 er ekki til, tha kemur til sogunnar HTTP Status Codes (404) = https://http.cat
200 = OK
201 = Created (fyrir post)
204 = No Content
400 = Bad Request
401 = Unauthorized
403 = Forbidden
404 = Not Found
500 = Internal Server Error


/*
 * ASP.NET Core
*/
// keyra thetta i command linu
dotnet new -t web
// restore-ar nuget
dotnet restore
dotnet build
dotnet run

nyjan controller: RecordsController.cs

setja upp postman

laera um versioning (Troy Hunt)

I stad thess ad setja [Route("api/courses/24")] a IActionResult, tha get eg notad nafnid sem er sett a controllerinn og baett bara vid:
[Route("{id}:int")]

Ekki nota baedi [HttpGet("{id}")] og [Route("{id}:int")]

Skjala forritid med:
/// <summary>
///
/// </summary>
fyrir ofan controller og foll
sja swagger.io

unit testa business logic, i services.

Gogn sem API skilar: -> DTO
Gogn sem Api tekur inn: -> ViewModel
Klasar sem mappast vid toflu: -> Entity

Interface er klasi med helling af follum en engri utfaerslu
Snidugt ad skipta Service upp i Implementation og Interfaces

throw exception fra service og catcha i controller, og returna http status koda thar.


nyja moppu i services sem heitir Exceptions og inni i Exception ad bua til:
AppObjectNotFoundException()
using System;
public class AppObjectNotFoundException : ApplicationException { // eda Exception
    
}

og i service er tha
throw new AppObjectNotFoundException(message);

var course = _db.Courses
            .Select(x => new CourseDetailsDTO {})
            .SingleOrDefault(x => x.Name == name);


left outer join tekur null fyrirbaeri med i linq
inner join = join t in ttt on t.id equals id
left outer join = joint t in ttt where t.id equals into typpi

setja [ForeignKey("")] fyrir ofan virtual i entity

[FromBody] er must! sem parameter

mkdir tests
dotnet new -t xunittest

using System;
using Xunit;

dotnet test

windows
[TestClass]
[TestInitialize]
[TestMethod]

left outer join a main teacher, til ad fa einnig null tho ad thad se enginn kennari

XML documentation:
///<param name="model">The data which indicates which person should be added as a teacher, and in what role</param>
public IActionResult blabla(AddTeacherViewModel model){}

bua til interface fyrir AppDataContext = IDBContext

Testinitializer keyrir a undan ollum follum i hvert einasta skipti.


var courseList = Builder<Course>.CreateListOfSize(10)
                        .TheFirst(6).With(x => x.Semester = "20153")
                        .TheLast(4).With(y => y.Semester = "20163")
                        .Build().ToList();


til ad fa watch til ad virka, tha setur madur i project.json:
"tools": {
    "Microsoft.DotNet.Watcher.Tools": "1.0.0-preview2-final"
    }


i stadinn fyrir ModelState.IsValid, ad vera tha frekar med:
CourseAPIValidation clasa og kalla sidan a hann i controllerinum med:
CourseAPIValidation.Validate(model);

setja a filter fyrir exception handling
bua til errorcodes clasa sem er constant fyrir error koda
bua til javascript fyrir clientinn sem breytir error kodanum i ensku, isl og spaensku.
Hafa thetta i Exceptions file-num i services


Fyrir object paging (item, page) tha getum vid gert i Utilities:
PageResult.cs
class PageInfo {
    public int PageSize {get; set;}
    puglic int TotalNumberOfItems {get; set;}
}
class PageResult<T> {
    public List<T> Items {get; set;}
    public PageInfo Paging {get; set;}
}

Skila PageResult<CourseInstanceDTO>


Security Token Service skilar Token og ser um authentication fyrir adra API
API-inn skodar sidan tokenid og kallar i STS til ad sja hvort ad Token se i lagi
STS getur sidan verid ad tala vid eitthvern annan gagnagrunn, t.d. facebook, twitter, adfs
Json web token er base64 encoded strengur, ekkert meira oryggi, bara scrambla.
Token skiptist i header, payload (data) og encodeing
Access token, id token, refresh token

[Authorize(Scope="admin")]

Til ad kalla i API med token, tha geriru i Http headers->authorization:
Bearer <tokenCode>

fyrir authentication: baeta vid reference of sma linur i setup.cs

Etag er notad fyrir caching. Client sendir fyrirspurn a api med etag, ef etagid er til (s.s. engar breytingar), sendir API-inn 304 (not modified) til baka og tha notar clientinn ur cache hja ser.


using Microsoft.AspNetCore.Authorization fyrir [Authorize]
Setja i project.json "IdentityServer4.AccessTokenValidation": "1.0.1-rc1"
tha geturu baett vid i Startup.cs:
public Configure(IApplicationBuilder app, ILoggerFactory loggerFactory) {
    loggerFactory.AddConsoleConfiguration.GetSection("Logging"));
    loggerFactory.AddDebug();

    app.UseIdentityServerAuthentication(new IdentityServerAuthenticationOptions {
        Authority = "http://localhost:5000",
        ScopeName = "api1",
        RequireHttpsMetadata = false
    });
    app.UseMvc();
}

I Program.cs baetiru vid i host = new WebHostBuilder()
    .UseUrls("http://localhost:5001")

mismunandi port! api a port 5000.
Sja github, Identityserver4

Inni i ConfigureServices(IServiceCollection services) i Startup.cs baeta vid:
services.AddMvc();
services.AddAuthorization(options => {
    options.AddPolicy("IsTeacher", policy => policy.RequireClaim("IsTeacher"));
});

[Authorize(Policy="IsTeacher")]

yo aspnet
Web Api Application
CoursesAuth
og i project.json kemur "IdentityServer4": "1.0.0-rc1-update2"
Og i configure fallinu i Startup.json a ad kalla i: app.UseIdentityServer();
I IdentityServernum: ConfigureServices startup.cs tharf ad kalla i:
services.AddDeveloperIdentityServer()
        .AddInMemoryScopes(Config.GetScopes())
        .AddInMemoryClients(Config.GetClients())
        .AddInMemoryUsers(Config.GetUsers())


vantar dotnet new fyrir console
C# clasa

var tokenClient = new TokenClient(disco.TokenEndpoint, "ro.client", "secret");
var tokenResponse = await tokenClient.RequestResourceOwnerPasswordAsync("alice", "password", "api1");
if (tokenResponse.IsError {}
Console.WriteLine(tokenResponse.Json);

dotnet -c Debug/Release

dev -> test -> prod

use AutoMapper to map between DTO objects and Entity classes

Monoliths er eins og vid erum buin ad gera,, bara einn API.
Microservices splittar thessu upp.
Ekki nota microservices nema thu sjair ad projectid se ordir rugl stort, tha mattu setja i micros.

Mismunandi service med mismunandi db eiga ad tala vid hvor adra, en ekki vid databaseinn hja hinum.

# Javascript
V name = statement; // where V e {let, const, var}
let er block scope en var er function scope, s.s. var lifir allstadar inni i falli, en let bara t.d. inni i if setningu.
Reyna bara ad nota let og const.
nota toString og parseInt

# Punchcard verkefni i node
--save-dev eru pakkar sem eru naudsynlegir a medan thad er verid ad throa, en ekki thegar thad er keyrt i production, t.d. pakkar fyrir einingaprofanir
--save mun nota i baedi production og development
npm init
npm install express --save
npm install er eins og dotnet restore

semver:
^1.2.0 segir allt sem er i major version (1.2.x, 1.1.x, 1.3.x etc.)
~1.2.0 segir allt sem er i minor version (1.2.1, 1.2.2 etc.)
0.x.x thydir ad thetta se i beta

# index.js
const express = require('express');
const app = express();

// geyma array af object
const companies = [];
const users = [];

// route
app.get('/api/companies', (req, res) => {
  // res.type('application/json'); // senda fra mer response af thessu tagi

  /*const data = [{
    id: 1,
    name: 'Forvit'
  }, {
    id: 2,
    name: 'Smuu'
  }];

  res.send(data);*/

  // res.send(companies);

  res.json(companies); // sleppum vid content type
});

app.post('/api/companies', (req, res) => {
  let newCompany = req.body;
  let comp = JSON.parse(newCompany);
  // if (comp.id)
  companies.push(comp);
});

app.get('/api/companies/:id', (req, res) => {
  //let id = parseInt(quotes(req.params.id));
  let id = parseInt(req.params.id);

  // ef query strengur (GET /search?q=tobi+ferret) tha er haegt ad gera
  //req.query.q

  if (id >= companies.length || id < 0) {
    res.statusCode = 404;
    // and return res.send('error 404, blabla');
  }
  res.json(companies[id]);
});

app.listen(process.env.PORT || 5000);


skoda body-parser middleware sem eru hjalpartol
##############

MongoDB er mjog hradur gagnagrunnur sem scalast vel.
Nota NoSQL fyrir t.d. chat eda skilabod. Ekki fyrir eitthvad sem a ad vera i rod.

mkdir /tmp/data
mongod --dbpath /tmp/data
// keyrir upp eina mongodb nodu
// haegt ad keyra tiu sem tengjast saman (horizontal scaling) og ef einn deyr tha deyr ekki databaseinn.

i annarri skel keyrir madur:
mongo       // sem keyrir upp skel
db
show dbs        // synir alla databaseana i grunninum

thad er til database, inni i database-i er collection og inni i collection er document
show collections
use // til ad tengjast vid database
use myapp
db  // synir databaseinn
db.todos.insert({title: 'Check out socks drawer', created: new Date(), category: 'home'})
db.todos.count()
db.todos.find()     // skilar ollum documentum
for (var i = 0; i < 20; i = i + 1) {
    db.todos.insert({title: 'Todo ' + i, created: new Date(), category: 'home'});
}

db.todos.insert({title: 'Read pull request', created: new Date(), category: 'work'});
db.todos.insert({title: 'Hand in final project', created: new Date(), category: 'school'});
db.todos.find({'category': 'school'});

db.todos.insert({title: 'Hand in final project', created: new Date(), category: 'school', status: {postponed: false}});
db.todos.find({'status.postponed': false});

db.users.find({'$or': [{'username': 'bob'}, {'username': 'eve'}]);
db.users.find({'tags': {'$in': ['bot', 'developer']}});

#### mongo project 
npm install --save express
npm install --save mongodb
npm install --save body-parser
npm install --save nodemon          <---- *** restartar alltaf servernum ef thad verda breytingar
keyrir sidan node_modules/nodemon/bin/nodemon.js index.js

'use strict';

const todo = require('./todo'),   // ef eg sleppi . tha leitar hun i node_modules
      express = require('express'),
      bodyParser = require('body-parser'),
      ObjectId = require('mongodb').ObjectID;

const app = express();
app.use(bodyParser.json());

app.post('/api/todo', (req, res) => {
  const data = req.body;
  // validate data
  console.log(data);
  todo.addTodo(data, (err, dbrs) => {
    if (err) {
      res.status(500).send('Unable to insert todo');
      return;
    }
    res.status(201).send(dbrs.insertedIds[0] || '');
  );
});

app.get('/api/todo', (req, res) => {
  todo.getTodos({}, (err, docs) {
    console.log(err);
    console.log(docs);
    res.send(docs);
  });
});

app.get('/api/todo/:id', (req, res) => {
  const id = req.params.id;
  todo.getTodos({'_id': new ObjectID(id)}, (err, docs) {
    console.log(err);
    console.log(docs);
    res.send(docs[0]);
  });
});

app.listen(4000);


i todo.js:
'use strict';
const MongoClient = require('mongodb').MongoClient;
const url = 'mongodb://localhost:27017/myapp';

const getTodos = (query, cb) => {
  MongoClient.connect(url, (err, db) => {
    if (err) {
      cb(err);
      db.close();
      return;
    }

// lika til findOne fyrir GET id
    const collection = db.collection('todo');
    collection.find(query).toArray((ierr, docs) => {
      cb(null, docs);
      db.close();
    });

  }
};

const addTodo = (todo, cb) => {
  MongoClient.connect(url, (err, db) => {
    if (err) {
      cb(err);
      db.close();
      return;
    }

    const collection = db.collection('todo');
    collection.insert(todo, (ierr, res) => {
      if (ierr) {
        cb(ierr);
        db.close();
        return;
      }
      cb(null, res);
    });
  });
}

module.exports = {
  addTodo: addTodo,
  getTodos: getTodos
}


##### ass8
nota uuid packa sem generate-ar token
ma hardkoda admin token
(nota yarn)
npm install --save express
#############index.js
const express = require("express");
const mongoose = require("mongoose");
const app = express();
const api = require("./api");
const port = 4000;

app.use("/api", api); // og tha get eg slept /api

//mongoose.connect("mongodb://localhost:27017/punchapi");
//mongoose.connect("localhost/punchapi");
mongoose.connection.once("open", () => {
    console.log("Connected to database");
    app.listen(port, () => {
        console.log("Web server started on port " + port);   
    });
});

###############api.js
const express = require("express");
const entities = require("./entities");
const uuid = require("node-uuid");
const app = export();
const adminToken = "smuu";


app.get("/api/users", (req, res) => {
    entities.User.find(function(err, docs) {
        if (err) {
            return res.status(500).send(err);
        } else {
            //TODO: henda token burt!
        }
    }); 
});

app.get("/api/users:id", (req, res) => {
    var query = {
        _id: req.params.id
    };
    //entities.User.find(query);
});

api.post("/api/users", (req, res) => {
    if (req.headers.Authorization !== adminToken) {
        return res.status(401).send("Not authorized";
    }
    // uuid.v1();
    
    let data = {
        name: req.body.name,
        gender: req.body.gender,
        token: uuid.v1()
    };

    let entity = new entities.User(data);   // byr til instance i minni
    entity.save((err) => {
        if (err) {
            return res.status(412).send("precondition failed");
        } else {
            return res.status(201).send({
                _id: entity._id,
                token: data.token
            });
        }
    });
});

app.get("/my/punches", (req, res) => {
    const token = req.headers.Authorization;
    var query = {
        token: token
    };
    let user = entities.User.find(query, (err, doc) => { //use find one instead
        console.log(doc);   
        if (doc.length !== 1) {
            
        }
    });
});

module.exports {
};

module.export = app;

############entities.js npm install --save mongoose
const mongoose = require("mongoose");

const UsersSchema = new mongoose.Schema({
    //name: String,
    name: {
        type: String,
        required: true
    },
    token: String,
    gender: {
        type: String,
        validate: {
            validator: function(value) {
                if (value === "m" || value === "f" || value === "o") return true;
                return false;
            },
            message: "blabla"
        }
    },
    bla: {
        type: Number,
        min: [10, "Why no"],
        max: 11
    },
    drink: {
        type: String,
        enum: ["Coffee", "Tea"]
    }
    // Number, Date, Buffer, Boolean, Mixed, ObjectId, Array
});

const PunchSchema = new mongoose.Schema({
    created: {
        type: Date,
        default: new Date()
    }
});

const UserEntity = mongoose.model("Users", UsersSchema);

const entities = {
    User: UserEntity
};
module.export = entities;








