// rendered on server
public ActionResult bla() {
    return View(new ViewModel());
}

// rendered on client
public ActionResult bla() {
    return Json(new ViewModel(), JsonBehavior.AllowGet);
}


/*
 * rest service
*/

/records
/records/75
/records/75/songs/842/lyrics

/records
/songs
/performers

(ekki bua til api sem er svona: /getrecords)
HTTP Verbs bydur upp a GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD, ...
hafa frekar resource-id /records

        /records                /records/75
GET     skilar lista            skilar staki
POST    byr til nyja plotu      X
PUT     X                       
DELETE  eydir lista             eydir staki
PATCH   X                       breytir staki (ad hluta)


Ef GET a 75 er ekki til, tha kemur til sogunnar HTTP Status Codes (404) = https://http.cat
200 = OK
201 = Created (fyrir post)
204 = No Content
400 = Bad Request
401 = Unauthorized
403 = Forbidden
404 = Not Found
500 = Internal Server Error


/*
 * ASP.NET Core
*/
// keyra thetta i command linu
dotnet new -t web
// restore-ar nuget
dotnet restore
dotnet build
dotnet run

nyjan controller: RecordsController.cs

setja upp postman

laera um versioning (Troy Hunt)

I stad thess ad setja [Route("api/courses/24")] a IActionResult, tha get eg notad nafnid sem er sett a controllerinn og baett bara vid:
[Route("{id}:int")]

Ekki nota baedi [HttpGet("{id}")] og [Route("{id}:int")]

Skjala forritid med:
/// <summary>
///
/// </summary>
fyrir ofan controller og foll
sja swagger.io

unit testa business logic, i services.

Gogn sem API skilar: -> DTO
Gogn sem Api tekur inn: -> ViewModel
Klasar sem mappast vid toflu: -> Entity

Interface er klasi med helling af follum en engri utfaerslu
Snidugt ad skipta Service upp i Implementation og Interfaces

throw exception fra service og catcha i controller, og returna http status koda thar.


nyja moppu i services sem heitir Exceptions og inni i Exception ad bua til:
AppObjectNotFoundException()
using System;
public class AppObjectNotFoundException : ApplicationException { // eda Exception
    
}

og i service er tha
throw new AppObjectNotFoundException(message);

var course = _db.Courses
            .Select(x => new CourseDetailsDTO {})
            .SingleOrDefault(x => x.Name == name);


left outer join tekur null fyrirbaeri med i linq
inner join = join t in ttt on t.id equals id
left outer join = joint t in ttt where t.id equals into typpi

setja [ForeignKey("")] fyrir ofan virtual i entity

[FromBody] er must! sem parameter

mkdir tests
dotnet new -t xunittest

using System;
using Xunit;

dotnet test

windows
[TestClass]
[TestInitialize]
[TestMethod]

left outer join a main teacher, til ad fa einnig null tho ad thad se enginn kennari

XML documentation:
///<param name="model">The data which indicates which person should be added as a teacher, and in what role</param>
public IActionResult blabla(AddTeacherViewModel model){}

bua til interface fyrir AppDataContext = IDBContext

Testinitializer keyrir a undan ollum follum i hvert einasta skipti.


var courseList = Builder<Course>.CreateListOfSize(10)
                        .TheFirst(6).With(x => x.Semester = "20153")
                        .TheLast(4).With(y => y.Semester = "20163")
                        .Build().ToList();


til ad fa watch til ad virka, tha setur madur i project.json:
"tools": {
    "Microsoft.DotNet.Watcher.Tools": "1.0.0-preview2-final"
    }


i stadinn fyrir ModelState.IsValid, ad vera tha frekar med:
CourseAPIValidation clasa og kalla sidan a hann i controllerinum med:
CourseAPIValidation.Validate(model);

setja a filter fyrir exception handling
bua til errorcodes clasa sem er constant fyrir error koda
bua til javascript fyrir clientinn sem breytir error kodanum i ensku, isl og spaensku.
Hafa thetta i Exceptions file-num i services


Fyrir object paging (item, page) tha getum vid gert i Utilities:
PageResult.cs
class PageInfo {
    public int PageSize {get; set;}
    puglic int TotalNumberOfItems {get; set;}
}
class PageResult<T> {
    public List<T> Items {get; set;}
    public PageInfo Paging {get; set;}
}

Skila PageResult<CourseInstanceDTO>


Security Token Service skilar Token og ser um authentication fyrir adra API
API-inn skodar sidan tokenid og kallar i STS til ad sja hvort ad Token se i lagi
STS getur sidan verid ad tala vid eitthvern annan gagnagrunn, t.d. facebook, twitter, adfs
Json web token er base64 encoded strengur, ekkert meira oryggi, bara scrambla.
Token skiptist i header, payload (data) og encodeing
Access token, id token, refresh token

[Authorize(Scope="admin")]

Til ad kalla i API med token, tha geriru i Http headers->authorization:
Bearer <tokenCode>

fyrir authentication: baeta vid reference of sma linur i setup.cs

Etag er notad fyrir caching. Client sendir fyrirspurn a api med etag, ef etagid er til (s.s. engar breytingar), sendir API-inn 304 (not modified) til baka og tha notar clientinn ur cache hja ser.


using Microsoft.AspNetCore.Authorization fyrir [Authorize]
Setja i project.json "IdentityServer4.AccessTokenValidation": "1.0.1-rc1"
tha geturu baett vid i Startup.cs:
public Configure(IApplicationBuilder app, ILoggerFactory loggerFactory) {
    loggerFactory.AddConsoleConfiguration.GetSection("Logging"));
    loggerFactory.AddDebug();

    app.UseIdentityServerAuthentication(new IdentityServerAuthenticationOptions {
        Authority = "http://localhost:5000",
        ScopeName = "api1",
        RequireHttpsMetadata = false
    });
    app.UseMvc();
}

I Program.cs baetiru vid i host = new WebHostBuilder()
    .UseUrls("http://localhost:5001")

mismunandi port! api a port 5000.
Sja github, Identityserver4

Inni i ConfigureServices(IServiceCollection services) i Startup.cs baeta vid:
services.AddMvc();
services.AddAuthorization(options => {
    options.AddPolicy("IsTeacher", policy => policy.RequireClaim("IsTeacher"));
});

[Authorize(Policy="IsTeacher")]

yo aspnet
Web Api Application
CoursesAuth
og i project.json kemur "IdentityServer4": "1.0.0-rc1-update2"
Og i configure fallinu i Startup.json a ad kalla i: app.UseIdentityServer();
I IdentityServernum: ConfigureServices startup.cs tharf ad kalla i:
services.AddDeveloperIdentityServer()
        .AddInMemoryScopes(Config.GetScopes())
        .AddInMemoryClients(Config.GetClients())
        .AddInMemoryUsers(Config.GetUsers())


vantar dotnet new fyrir console
C# clasa

var tokenClient = new TokenClient(disco.TokenEndpoint, "ro.client", "secret");
var tokenResponse = await tokenClient.RequestResourceOwnerPasswordAsync("alice", "password", "api1");
if (tokenResponse.IsError {}
Console.WriteLine(tokenResponse.Json);

dotnet -c Debug/Release

dev -> test -> prod

use AutoMapper to map between DTO objects and Entity classes












